/**
 *
 * @file interrupts.cpp
 * @author Sasisekhar Govind
 *
 */

#include "interrupts.hpp"

int main(int argc, char **argv)
{

    // vectors is a C++ std::vector of strings that contain the address of the ISR
    // delays  is a C++ std::vector of ints that contain the delays of each device
    // the index of these elemens is the device number, starting from 0
    auto [vectors, delays] = parse_args(argc, argv);
    std::ifstream input_file(argv[1]); // ifstream is used to read from files and it's part of the standard library

    std::string trace;     //!< string to store single line of trace file
    std::string execution; //!< string to accumulate the execution output

    /******************ADD YOUR VARIABLES HERE*************************/
  
    int time_of_event = 0;
    int context_save_time = 30;
    int previous_CPU_time;
    int isr_activity_time = 40;
    


    /******************************************************************/

    // parse each line of the input trace file
    while (std::getline(input_file, trace))
    {

        auto [activity, duration_intr] = parse_trace(trace); // parse_trace will return a tuple: ('CPU', 50)

        /******************ADD YOUR SIMULATION CODE HERE*************************/
       
        if (activity == "CPU")
        {
          

          
            

            execution += std::to_string(time_of_event ) + ", " + std::to_string(duration_intr) + ", " + "CPU burst\n";

            previous_CPU_time = duration_intr;
        }

        if (activity == "SYSCALL")
        {
            // 51, 1, switch to kernel mode
            // 52, 10, context saved
            // 62, 1, find vector 14 in memory position 0x001C
            // 63, 1, load address 0X0165 into the PC  -- until here the execution is generated by the ISR
            // 64, 40, SYSCALL: run the ISR (device driver)
            // 104, 40, transfer data from device to memory
            // 144, 376, check for errors
            time_of_event += previous_CPU_time;
            auto [isr_syscall_execution_string, current_time] = intr_boilerplate(time_of_event, duration_intr, context_save_time, vectors);
            time_of_event = current_time;
            execution += isr_syscall_execution_string;

            
            execution += std::to_string(time_of_event ) + ", " + std::to_string(isr_activity_time) + ", " + "SYSCALL: run the ISR (device driver)\n";
            time_of_event += isr_activity_time;
            execution += std::to_string(time_of_event ) + ", " + std::to_string(isr_activity_time) + ", " + "transfer data from device to memory\n";
            time_of_event += isr_activity_time;
            // execution += std::to_string(time_of_event ) + ", " + std::to_string(isr_activity_time) + ", " + "check for errors\n";
            execution += std::to_string(time_of_event ) + ", " + std::to_string(1) + ", " + "IRET\n";
            time_of_event ++;
            
            
            
            


           
        }

        if (activity == "END_IO")
        {
            // 559, 1, switch to kernel mode
            // 560, 10, context saved
            // 570, 1, find vector 14 in memory position 0x001C
            // 571, 1, load address 0X0165 into the PC
            // 572, 40, ENDIO: run the ISR (device driver)
            // 612, 416, check device status

            time_of_event += previous_CPU_time;
            auto [isr_endio_execution_string, current_time] = intr_boilerplate(time_of_event, duration_intr, context_save_time, vectors);

            execution += isr_endio_execution_string;
            time_of_event = current_time;
           

            execution += std::to_string(time_of_event ) + ", " + std::to_string(isr_activity_time) + ", " + "ENDIO: run the ISR (device driver)\n";
            time_of_event += isr_activity_time;

            execution += std::to_string(time_of_event ) + ", " + std::to_string(1) + ", " + "IRET\n";
            time_of_event ++;

            
        }

      
        

     
        /************************************************************************/
    }

    input_file.close();

    write_output(execution);

    return 0;
}
